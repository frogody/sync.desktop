# Notch Action Approval System — Design Document

**Date**: 2026-02-27
**Status**: Approved
**Scope**: sync.desktop (Electron + Swift) + app.isyncso (Edge Functions + DB)

---

## Summary

Replace the current multi-feature notch widget (chat, voice, context display) with a single-purpose **one-click action approval system**. The desktop app uses a local MLX model for instant detection of actionable events, shows a minimal notification in the macOS notch, and coordinates with app.isyncso for validation, enrichment, and execution.

---

## Architecture

### Two-Tier AI System

**Tier 1 — Local (Swift + MLX, ~50-200ms)**
- Runs in the SYNCWidget Swift process
- Classifies context events: "Is this actionable?"
- Generates notification text for the notch
- Shows notification immediately (no network round-trip)

**Tier 2 — Cloud (app.isyncso edge functions, ~1-3s)**
- Validates the action (e.g., is the meeting already in calendar?)
- Enriches with integration data (contact details, free time slots)
- Prepares full execution payload (Composio API calls, etc.)
- May update the notch notification with richer details

### Data Flow

```
[Desktop] DeepContextEngine detects event (commitment, email pattern, etc.)
    |
    v (JSON via stdin pipe)
[SYNCWidget] MLX model classifies event (~100ms)
    |
    ├─ confidence > 0.7 → Show in notch immediately
    ├─ confidence > 0.5 → Send to cloud for validation (don't show yet)
    └─ confidence < 0.5 → Discard
    |
    v (via NotchBridge → Electron → HTTP)
[Edge Function] analyze-action
    |── Validates against real data
    |── Enriches with integration details
    |── Prepares execution payload
    |
    v (INSERT/UPDATE)
[Supabase] pending_actions table
    |
    v (Realtime subscription)
[Desktop] ActionService receives update
    |── Updates notch if cloud enriched the text
    |── Confirms sync (ack)
    |
    v (user taps ✅)
[Edge Function] execute-action
    |── Runs prepared action via Composio/internal
    |── Updates status to completed
    |
    v (Realtime push)
[Desktop] Notch shows success animation → dismiss
```

---

## Coordination Protocol

### State Machine

```
detected → analyzing → pending → approved → executing → completed
                                    ├─→ failed
                            ├─→ dismissed (user tapped ✕)
                            └─→ expired (TTL 1 hour)
```

### Event Deduplication

Each context event gets a fingerprint:
```
event_hash = SHA256(event_type + source_app + summary_normalized + timestamp_rounded_to_minute)
```

Both local SQLite and cloud `pending_actions` enforce UNIQUE on `event_hash` — same event cannot generate two actions.

### Acknowledgment Flow

1. Desktop generates `action_id` (UUID) + `event_hash`
2. Desktop POSTs to `analyze-action` with both identifiers
3. Cloud processes and INSERTs `pending_actions` with matching `id`
4. Desktop receives via Supabase Realtime → marks as synced
5. If no Realtime ack within 10s → desktop polls as fallback
6. On approve: desktop POSTs to `execute-action` with `action_id`
7. Cloud executes and updates status → Realtime pushes back

### Conflict Resolution

- If cloud validation rejects the action (e.g., meeting already in calendar): status → `invalidated`, notch dismisses with brief "Already done" message
- If cloud enriches with different title: notch updates text smoothly
- If desktop is offline when cloud responds: action queued in `pending_actions`, shown when desktop reconnects via Realtime catch-up

---

## Database Schema

### Supabase: `pending_actions`

```sql
CREATE TABLE pending_actions (
  id UUID PRIMARY KEY,                    -- generated by desktop
  user_id UUID REFERENCES auth.users(id) NOT NULL,
  company_id UUID NOT NULL,

  -- Display
  title TEXT NOT NULL,                    -- notch notification text (max 60 chars)
  subtitle TEXT,                          -- optional detail line

  -- Action definition
  action_type TEXT NOT NULL,              -- calendar_event, task_create, email_reply, reminder, etc.
  action_payload JSONB NOT NULL DEFAULT '{}', -- full execution details

  -- Detection context
  event_hash TEXT NOT NULL,               -- dedup fingerprint
  trigger_context JSONB,                  -- the context event that caused detection
  local_confidence REAL,                  -- MLX model confidence (0-1)
  cloud_confidence REAL,                  -- cloud validation confidence (0-1)

  -- Lifecycle
  status TEXT NOT NULL DEFAULT 'pending',
  status_message TEXT,                    -- "Already in calendar", "Failed: auth expired", etc.

  created_at TIMESTAMPTZ DEFAULT now(),
  resolved_at TIMESTAMPTZ,
  expires_at TIMESTAMPTZ DEFAULT (now() + interval '1 hour'),

  CONSTRAINT unique_event UNIQUE (user_id, event_hash)
);

CREATE INDEX idx_pending_actions_user_status ON pending_actions(user_id, status);
CREATE INDEX idx_pending_actions_expires ON pending_actions(expires_at) WHERE status = 'pending';

ALTER PUBLICATION supabase_realtime ADD TABLE pending_actions;

ALTER TABLE pending_actions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Users manage own actions" ON pending_actions
  FOR ALL USING (user_id = auth.uid());
```

### Local SQLite: `local_actions`

```sql
CREATE TABLE local_actions (
  action_id TEXT PRIMARY KEY,       -- UUID, matches pending_actions.id
  event_hash TEXT UNIQUE NOT NULL,  -- dedup
  status TEXT NOT NULL DEFAULT 'detected',
  local_title TEXT NOT NULL,        -- from MLX
  cloud_title TEXT,                 -- from cloud enrichment
  action_type TEXT NOT NULL,
  local_payload TEXT,               -- JSON from MLX
  confidence REAL,
  synced INTEGER DEFAULT 0,         -- 0=not synced, 1=synced to cloud
  created_at TEXT DEFAULT (datetime('now')),
  resolved_at TEXT
);
```

---

## Swift Widget Changes

### States (reduced from 8 → 3)

```swift
enum WidgetState: String, CaseIterable {
    case idle           // Invisible (unchanged)
    case actionPending  // Notification bar: text + ✅ + ✕
    case actionSuccess  // Brief green pulse → auto-dismiss to idle
}
```

### Remove Entirely

- `compactChat`, `expandedChat` states + ChatMessage model
- `voiceListening`, `voiceSpeaking` states
- `thinking`, `knocking`, `hovering` states
- `ExpandedChatView`, `HoverGlowView`
- `SSEClient`, `VoiceClient`, `SpeechRecognizer`, `KeyboardCapture`
- All chat-related ViewModel code (sendChatMessage, streaming, etc.)

### Add

- `ActionClassifier` — MLX model wrapper for event classification
- `ActionPendingView` — dark pill UI: text + ✅ button + ✕ button
- `ActionSuccessView` — brief green checkmark animation

### MLX Integration

```swift
// Using mlx-swift (Apple's official Swift bindings)
// Package.swift dependency:
// .package(url: "https://github.com/ml-explore/mlx-swift", from: "0.21.0")

// Model: Qwen2.5-1.5B-4bit (~800MB) or SmolLM2-1.7B-4bit (~600MB)
// Bundled in app Resources/
// Loaded once on startup, kept in memory

// Classification prompt:
let prompt = """
<context>
\(contextEventJSON)
</context>

Is this actionable? Respond ONLY in JSON:
{"actionable":bool,"type":"calendar_event|task_create|email_reply|reminder|none","title":"max 50 char notch text","confidence":0.0-1.0}
"""
```

### Notch UI (ActionPendingView)

Matches the reference image exactly:
- Dark semi-transparent pill shape extending from the notch
- White text: "Add meeting with Thomas to Calendar?"
- Green circle checkmark (✅) on the right
- Small ✕ dismiss on the left edge
- Appears with a spring animation from behind the notch
- Auto-dismisses after 60 seconds if no interaction

---

## Bridge Protocol Updates

### Electron → Swift (new messages)

| Type | Payload | Purpose |
|------|---------|---------|
| `context_event` | `{ eventType, summary, entities, commitments, ... }` | Raw event for MLX classification |
| `show_action` | `{ id, title, subtitle?, actionType }` | Cloud-enriched action (update or new) |
| `hide_action` | `{ id, reason? }` | Dismiss (invalidated, expired, etc.) |
| `action_result` | `{ id, success, message? }` | Execution result |

### Swift → Electron (new messages)

| Type | Payload | Purpose |
|------|---------|---------|
| `action_detected` | `{ id, eventHash, title, actionType, confidence, localPayload }` | MLX found actionable event |
| `action_approved` | `{ id }` | User tapped ✅ |
| `action_dismissed` | `{ id }` | User tapped ✕ |

### Removed messages

- `context_update` (replaced by `context_event` with richer data)
- `sync_status` (no longer relevant)
- `context_boost`, `context_normal` (no more boost/idle polling)
- `widget_state` with old states
- `trigger_sync` (no manual sync from widget)

---

## Edge Functions

### `analyze-action` (new)

**Endpoint**: `POST /functions/v1/analyze-action`

**Input**:
```json
{
  "action_id": "uuid",
  "event_hash": "sha256",
  "user_id": "uuid",
  "company_id": "uuid",
  "action_type": "calendar_event",
  "local_title": "Add meeting with Thomas to Calendar?",
  "local_confidence": 0.85,
  "trigger_context": { ... full context event ... }
}
```

**Processing**:
1. Check dedup: does `event_hash` already exist in `pending_actions`?
2. Validate: query user's integrations (Composio connections)
3. Check existing state:
   - For `calendar_event`: does this event already exist in Google Calendar?
   - For `task_create`: does this task already exist?
4. Enrich: pull contact details, suggest time slots, fill in missing data
5. Prepare execution payload (full Composio API call parameters)
6. INSERT into `pending_actions`

**Output** (also stored in DB):
```json
{
  "action_id": "uuid",
  "status": "pending",
  "title": "Add meeting with Thomas (Thu 2pm) to Calendar?",
  "action_payload": {
    "integration": "google_calendar",
    "operation": "create_event",
    "params": {
      "summary": "Meeting with Thomas",
      "start": "2026-02-28T14:00:00+01:00",
      "end": "2026-02-28T15:00:00+01:00",
      "attendees": ["thomas@example.com"]
    }
  }
}
```

### `execute-action` (new)

**Endpoint**: `POST /functions/v1/execute-action`

**Input**:
```json
{
  "action_id": "uuid",
  "user_id": "uuid"
}
```

**Processing**:
1. Fetch `pending_actions` row, verify status = 'pending' or 'approved'
2. Update status → 'executing'
3. Execute via Composio or internal DB (based on `action_type`)
4. Update status → 'completed' or 'failed' with `status_message`

---

## Desktop Services

### `ActionService` (new — `src/main/services/actionService.ts`)

Responsibilities:
- Subscribes to `pending_actions` via Supabase Realtime (filtered by user_id)
- Listens for `action_detected` from NotchBridge (local MLX detections)
- POSTs to `analyze-action` for cloud enrichment
- On Realtime update: forwards to NotchBridge for display updates
- On `action_approved` from NotchBridge: POSTs to `execute-action`
- On `action_dismissed`: updates `pending_actions` status
- Manages local SQLite `local_actions` table for offline tracking
- Handles acknowledgment + fallback polling
- Cleans up expired actions

### NotchBridge Updates (`src/main/services/notchBridge.ts`)

- Replace `sendContextUpdate()` with `sendContextEvent()` — sends individual events, not periodic summaries
- Add handlers for new Swift→Electron messages: `action_detected`, `action_approved`, `action_dismissed`
- Remove: `sendSyncStatus()`, context boost/normal handling
- Add: `sendActionUpdate()`, `sendActionResult()`, `hideAction()`

---

## Implementation Phases

### Phase 1: Database + Edge Functions
1. Create `pending_actions` migration
2. Build `analyze-action` edge function
3. Build `execute-action` edge function
4. Enable Realtime on `pending_actions`

### Phase 2: Desktop ActionService
1. Create `ActionService` with Realtime subscription
2. Create `local_actions` SQLite table
3. Wire up DeepContextEngine events → ActionService
4. Implement coordination protocol (dedup, ack, fallback)

### Phase 3: Swift Widget Redesign
1. Strip chat/voice/hover code from SYNCWidget
2. Reduce WidgetState to 3 states
3. Build `ActionPendingView` (dark pill + text + ✅ + ✕)
4. Build `ActionSuccessView` (green pulse animation)
5. Update bridge messages

### Phase 4: MLX Integration
1. Add `mlx-swift` dependency to Package.swift
2. Bundle quantized model (Qwen2.5-1.5B-4bit or SmolLM2-1.7B-4bit)
3. Build `ActionClassifier` service
4. Wire context events → classifier → notch display
5. Confidence thresholds: >0.7 show, >0.5 send to cloud, <0.5 discard

### Phase 5: Integration Testing
1. End-to-end: commitment detected → notch → approve → executed
2. Dedup: same event doesn't create multiple actions
3. Offline: actions queue and show when reconnected
4. Cloud invalidation: already-done actions dismiss gracefully
5. TTL: expired actions auto-dismiss

---

## Model Selection

| Model | Size (Q4) | Speed (M2) | Quality | Recommendation |
|-------|-----------|-------------|---------|----------------|
| SmolLM2-1.7B | ~600MB | ~50ms | Good for classification | Best speed |
| Qwen2.5-1.5B | ~800MB | ~80ms | Better structured output | **Recommended** |
| Phi-3.5-mini-3.8B | ~1.8GB | ~150ms | Best quality | If app size isn't a concern |

Start with Qwen2.5-1.5B — good balance of speed, size, and structured JSON output quality. Can upgrade to Phi-3.5-mini if classification accuracy needs improvement.

---

## Success Criteria

- Detection to notch notification: < 300ms (local MLX)
- Cloud enrichment round-trip: < 3s
- Zero duplicate actions for same event
- Zero missed actions (ack + fallback polling)
- Notch UI matches reference: clean dark pill, white text, green ✅
- Action execution < 5s after approval
